
---------------
Maps (Topic)
---------------
Flutter Google maps
---------------------
Fix for google maps flutter which causes the application to crash when popping the map screen


final GoogleMapsFlutterPlatform mapsImplementation =
      GoogleMapsFlutterPlatform.instance;
  if (mapsImplementation is GoogleMapsFlutterAndroid) {
    try {
      await mapsImplementation
          .initializeWithRenderer(AndroidMapRenderer.latest);
    } catch (e) {}
  }

place this in main(), it uses the latest rendering.

How to display google maps in flutter and draw polyline between two points
---------------------------------------------------------------------------

After setting up your app and the google maps keys.

class MapScreen extends StatefulWidget{
.....
class _MapScreenState..... {
 late GoogleMapController mapController;
 BitmapDescriptor? myLocationMarker;
 BitmapDescriptor? secondUserLocationMarker;
 Map<PolylineId, Polyline> polyLines = {};
 
 @override
 void initState(){
  //Get users location
  WidgetsBinding.instance.addPostFrameCallback((duration) {
   initializeMarkers();
  });
 }

 @override
 Widget build(BuildContext context){
  return Scaffold(
    appBar: AppBar(),
    body: (location == null) ? Center(child: Text("Loading")) : 
     GoogleMap(
      trafficEnabled: true, //To show traffic lines,
      initialCameraPosition: CameraPosition(
        target: location, //which is LatLng()
      ),
      markers: { //A set of markers
        if (myLocationMarker != null)
             Marker(
               markerId: MarkerId("my_location"),
               position: mylocation,
               icon: myLocationMarker!,
               infoWindow: const InfoWindow(title: "Your Location"),
               ),
         if (secondUserLocationMarker != null)
             Marker(
               markerId: MarkerId("alarrt_location"),
               position: LatLng(latitude, longitude),
               icon: secondUserLocationMarker!,
               infoWindow: InfoWindow(
               title: "${widget.firstName} ${widget.lastName}",
               snippet: widget.address),
          ),
      },
      onMapCreated: (GoogleMapController controller) async {
         mapController = controller;

         if (appStore.isDarkMode) {
           await controller.setMapStyle(darkMapStyle);
         } else {
           await controller.setMapStyle(lightMapStyle);
         }

         await Future.delayed(1.seconds, () async {
            mapController.animateCamera(
              CameraUpdate.newCameraPosition(CameraPosition(
              target: provider.currentPosition!,
              zoom: 7,
          )));
         });
          setState(() {});
      } ,
        polylines: Set<Polyline>.of(polyLines.values),
      )
    
  );
  
  void initializeMarkers() async {
    //Create marker for my location
    // Create a marker using image or widgets, using MarkerIcon package
    if (myProfilePic == null ||
        ) {

      myLocationMarker = await MarkerIcon.circleCanvasWithText(
        text: "${firstName[0].toUpperCase()}"
            "${lastName[0].toUpperCase()}",
        size: Size(70, 70),
        fontSize: 25,
        circleColor: primaryBlue,
        fontColor: Colors.white,
      );
    } else {
      myLocationMarker = await MarkerIcon.downloadResizePictureCircle(
          myprofilePic!,
          size: 90,
          addBorder: true,
          borderSize: 15);
    }

    //create marker for second location
    if (widget.profilePic == null ) {
      alertCreatorLocationMarker = await MarkerIcon.circleCanvasWithText(
        text: "${widget.firstName[0].toUpperCase()}"
            "${widget.lastName[0].toUpperCase()}",
        size: Size(70, 70),
        fontSize: 25,
        circleColor: primaryBlue,
        fontColor: Colors.white,
      );
    } else {
      alertCreatorLocationMarker = await MarkerIcon.downloadResizePictureCircle(
          widget.profilePic!,
          size: 90,
          addBorder: true,
          borderSize: 15);
    }

    setState(() {});
  }
 }


Next to get the polyline we use the directions api from google maps in this api
you can either use placeID, latitude_longitude, or address, we will be using 
longitude_latitude but the best is placeID because it has more data packed in it
so google does not have to make multiple calls to other endpoints thus it is 
faster.

Here is an example of basic request to get directions, we use the alternatives: true,
parameters which resturns alternative routes.

Future<NetworkResponse> getDirectionsFromLatLng({
    required LatLng origin,
    required LatLng destination,
  }) async {
    Uri requestUrl = Uri.parse(
        "${AppUrl.directionsBaseUrl}?origin=${origin.latitude},${origin
            .longitude}&"
            "destination=${destination.latitude},${destination.longitude}&"
            "alternatives=true&key="
            "$googleMapsApiKey&sessiontoken=viewAlarrt");
    try {
      final response =
      await http.get(requestUrl).timeout(Duration(seconds: 30));
      final result = jsonDecode(response.body);
      if (response.statusCode == 200) {
        final model = DirectionsModel.fromJson(result);
        return NetworkResponse(status: RequestStatus.success, data: model);
      } else {
        return NetworkResponse(
            status: RequestStatus.failed, data: "Invalid response");
      }
    } on TimeoutException catch (e) {
      debugPrint("request timeout");
      return NetworkResponse(status: RequestStatus.noNetwork, data: "No network");
    } on http.ClientException catch (e) {
      debugPrint("client exception: $e");
      return NetworkResponse(status: RequestStatus.noNetwork, data: "No network");
    } catch (e) {
      debugPrint("Error $e");
      return NetworkResponse(
          status: RequestStatus.failed, data: "Unkown error");
    }
  }

Then we want to parse the response and update our polyline map

Future<void> getDirections() async {
    LatLng myLocation = myCurrentPosition;
    LatLng usersLocation = LatLng(double.tryParse(widget.latitude!)!,
        double.tryParse(widget.longitude!)!);

    final response = await MapsRepo().getDirectionsFromLatLng(
      origin: myLocation,
      destination: usersLocation,
    );

    if (response.status == RequestStatus.failed) {
      //TODO show snackbar
    } else if (response.status == RequestStatus.noNetwork) {
      //TODO show snackbar
    } else {
      //Then it succeeded
      final data = response.data as DirectionsModel;
      directionsModel = data;
      int index = 0;

      for (Routes route in data.routes) {
        //Loop through all the routes and get the overview
        //polyline for each.
        //Then decoded it and get the list of LatLng from it.
        //Then create a polyline from this list and then save it with
        //a unique ID in polyLines variable,
        //Finally calling setState which causes it to render on the map.

        String overviewPolyline = route.overviewPolyline.points;

        final line = decodePolyline(overviewPolyline);  //package:google_polyline_algorithm
        final id = PolylineId(Random().nextInt(100).toString());

        List<LatLng> coOrdinates =
            line.map((e) => LatLng(e[0].toDouble(), e[1].toDouble())).toList();
        Polyline polyline = Polyline(
          polylineId: id,
          color: (index == 0) ? primaryBlue : t8_colorPrimary,
          points: coOrdinates,
          width: 3,
        );

        polyLines[id] = polyline;
        index++;
      }
    }

    if (mounted) {
      setState(() {});
    }
  }



26 August 2023
-----------------
Geospatial data
-----------------
sources:
https://aws.amazon.com/what-is/geospatial-data/#:~:text=Geospatial%20data%2C%20or%20geodata%2C%20is,by%20latitude%20and%20longitude%20coordinates.
https://www.ibm.com/topics/geospatial-data

Geospatial data, or geodata, is data that includes information related to 
locations on the Earth’s surface. You can map objects, events, and other 
real-world phenomena to a specific geographical area identified by latitude 
and longitude coordinates. 

Geospatial visualization
-------------------------
Geospatial visualization is when you create visualizations 
(such as maps and 3D models) using geospatial data.

Geospatial intelligence is a term that describes the 
collection, analysis, and interpretation of geospatial data for 
informed decision-making. It combines geographic data with 
various other types of intelligence—including imagery, signals 
intelligence, and human intelligence—to accurately represent a 
location and its physical environment.

Types of geospatial data
---------------------------
vector data:

Vector data is geospatial information that uses digital elements 
like points, lines, and polygons to represent geographic features. 
Vector data often represents physical features such as roads, rivers, 
and city boundaries. Vector data is widely used in geospatial information 
applications such as mapping, location information, and navigation.

For example, a visual representation using vector data might include 
houses represented by points, roads represented by lines and entire 
towns represented by polygons.

Raster data:
Rasters are geospatial data models that define space as a grid of 
equally sized cells. Each grid cell represents location information like 
temperature or soil quality. The raster is overlaid on a map image.

Raster data creates imagery that’s substantially more complex, such as 
photographs and satellite images.

Geospatial technology
----------------------
Geospatial technology refers to all the technology required for the 
collecting, storing and organizing of geographic information. It 
includes the satellite technology which allowed for the geographic 
mapping and analysis of Earth. Geospatial technology can be found in 
several related technologies, such as Geographic Information Systems (GIS), 
Global Positioning Systems (GPS), geofencing and remote sensing.

Geospatial analytics is used to add timing and location to traditional 
types of data and to build data visualizations. These visualizations 
can include maps, graphs, statistics and cartograms that show historical 
changes and current shifts.


Geospatial information systems (GIS) relate specifically to the physical 
mapping of data within a visual representation. For example, when a 
hurricane map (which shows location and time) is overlaid with another 
layer showing potential areas for lightning strikes, you’re seeing GIS 
in action.


27 August 2023
-------------------
Showing traffic on polyline
----------------------------










--------------------------------------------
Releasing flutter apps to store (Topic)
---------------------------------------------

1. Android (Google play store)
---------------------------------

1. create an upload keystore

keytool -genkey -v -keystore upload-keystore.jks -keyalg RSA \
          -keysize 2048 -validity 10000 -alias upload


2. Reference keystore from the app
------------------------------------
Create a file named key.properties in android/key.properties

storePassword=<password-from-previous-step>
keyPassword=<password-from-previous-step>
keyAlias=upload
storeFile=<keystore-file-location>

then edit android/app/build.gradle

add this before the android {} block

  def keystoreProperties = new Properties()
   def keystorePropertiesFile = rootProject.file('key.properties')
   if (keystorePropertiesFile.exists()) {
       keystoreProperties.load(new FileInputStream(keystorePropertiesFile))
   }
   
Find the buildTypes block and add this above:

signingConfigs {
       release {
           keyAlias keystoreProperties['keyAlias']
           keyPassword keystoreProperties['keyPassword']
           storeFile keystoreProperties['storeFile'] ? file(keystoreProperties['storeFile']) : null
           storePassword keystoreProperties['storePassword']
       }
   }
   
then add signingConfig signingConfigs.release to the 

release{} block so the whole thing becomes 

 buildTypes {
       release {
           signingConfig signingConfigs.debug
           signingConfig signingConfigs.release
       }
   }
   
your can remove signingConfigs.debug  




-----------------------------
FIREBASE (TOPIC)
-----------------------------
setup
------
After you download and setup firebase
> firebase login
> dart pub global activate flutterfire_cli
> flutterfire configure

add firebase_core package then in main.dart

await Firebase.initializeApp(
  options: DefaultFirebaseOptions.currentPlatform,
);





-------------------------------
24 august 2023
Protecting keys (TOPIC)
-------------------------------
1. Enviromemt variables

(Flutter_dotenv)

a. create a .env file in root of project

FOO=foo
BAR=bar
FOOBAR=$FOO$BAR
ESCAPED_DOLLAR_SIGN='$1000'
# This is a comment

b. Add the .env file to your assets bundle in pubspec.yaml

assets:
  - .env
  
c. Load the .env file in main.dart

import 'package:flutter_dotenv/flutter_dotenv.dart';

// DotEnv dotenv = DotEnv() is automatically called during import.
// If you want to load multiple dotenv files or name your dotenv object differently, 
// you can do the following and import the singleton into the relavant files:
// DotEnv another_dotenv = DotEnv()

Future main() async {
  // To load the .env file contents into dotenv.
  // NOTE: fileName defaults to .env and can be omitted in this case.
  // Ensure that the filename corresponds to the path in step 1 and 2.
  await dotenv.load(fileName: ".env");
  //...runapp
}

You can then access variables from .env throughout the application

import 'package:flutter_dotenv/flutter_dotenv.dart';
dotenv.env['VAR_NAME'];


Merging 
You can merge a map into the environment on load:

await DotEnv.load(mergeWith: { "FOO": "foo", "BAR": "bar"});


Null Safety

Future<void> main() async {
  await dotenv.load();

  String foo = dotenv.get('VAR_NAME');

  // Or with fallback.
  String bar = dotenv.get('MISSING_VAR_NAME', fallback: 'sane-default');

  // This would return null.
  String? baz = dotenv.maybeGet('MISSING_VAR_NAME', fallback: null);
}




---------------------
August 26 2023
Biometrics (TOPIC)
----------------------

1. local_auth: ^1.1.10

BiometricType.face
BiometricType.fingerprint
BiometricType.weak
BiometricType.strong


To check whether there is local authentication available 
on this device or not, call canCheckBiometrics 
(if you need biometrics support) and/or isDeviceSupported() 
(if you just need some device-level authentication):

final bool canAuthenticateWithBiometrics = await auth.canCheckBiometrics;
final bool canAuthenticate = canAuthenticateWithBiometrics || await auth.isDeviceSupported();

///Get a list of available biometric types.

final List<BiometricType> availableBiometrics = await auth.getAvailableBiometrics();

if (availableBiometrics.contains(BiometricType.fingerprint)...


///Authenticating
The authenticate() method uses biometric authentication when possible, but also allows 
fallback to pin, pattern, or passcode.

To require biometric authentication, pass AuthenticationOptions with biometricOnly set to true.

final bool didAuthenticate = await auth.authenticate(
    localizedReason: 'Please authenticate to show account balance',
    options: const AuthenticationOptions(biometricOnly: true));





-----------------
April 28 2023
-----------------
Json serialization (Topic)
-----------------------------
With this we can automate making of models 

using json_annotation, and json_serializable
--------------------------------------------
source::::
https://docs.flutter.dev/data-and-backend/serialization/json

add json_annotation to pub
and build_runner along with json_serializable to dev

example:::

part 'user.g.dart';

@JsonSerializable()
class User {
  User(this.name, this.email);

  String name;
  String email;
  
  @JsonKey(name: 'registration_date_millis')
  final int registrationDateMillis;
  
  factory User.fromJson(Map<String, dynamic> json) => _$UserFromJson(json);
  
  Map<String, dynamic> toJson() => _$UserToJson(this);
}


@JsonKey matches to variable gotten from the server to a different
name when creating the object.

Modifying @JsonSerializable(fieldRename: FieldRename.snake) is 
equivalent to adding @JsonKey(name: '<snake_case>') to each field.

ways to verify the data
------------------------
@JsonKey(defaultValue: false)
final bool isAdult;

@JsonKey(required: true)
final String id;

@JsonKey(ignore: true)
final String verificationCode;

generating the output
-----------------------
i. one time code generation
dart run build_runner build --delete-conflicting-outputs 

ii. generating code continuously
dart run build_runner watch --delete-conflicting-outputs

generating code for nested classes
-----------------------------------
@JsonSerializable()
class Address {
  String street;
  String city;

  Address(this.street, this.city);

  factory Address.fromJson(Map<String, dynamic> json) =>
      _$AddressFromJson(json);
  Map<String, dynamic> toJson() => _$AddressToJson(this);
}

import 'package:json_annotation/json_annotation.dart';

import 'address.dart';

part 'user.g.dart';

@JsonSerializable()
class User {
  User(this.name, this.address);

  String name;
  Address address;

  factory User.fromJson(Map<String, dynamic> json) => _$UserFromJson(json);
  Map<String, dynamic> toJson() => _$UserToJson(this);
}




--------------------
April 30 2023
----------------------------
Notifications
----------------------------
1. Firebase Cloud Messaging

Life cycle flow
----------------
1. Register devices to receive messages from FCM. An instance of a 
client app registers to receive messages, obtaining a registration 
token that uniquely identifies the app instance.

2. Send and receive downstream messages.
   i. Send a message. The app server sends messages to the client app:

        a. The message is composed, either in the Notifications composer or a 
        trusted environment, and a message request is sent to the FCM backend.
        
        b. The FCM backend receives the message request, generates a message ID 
        and other metadata, and sends it to the platform specific transport layer.
        
        c. When the device is online, the message is sent via the platform-specific 
        transport layer to the device.

        d. On the device, the client app receives the message or notification.

Message types
--------------
i. Notification message
ii. Data message

Notification messages contain a predefined set of user-visible keys. Data messages, 
by contrast, contain only your user-defined custom key-value pairs. Notification 
messages can contain an optional data payload. Maximum payload for both message 
types is 4000 bytes, except when sending messages from the Firebase console, which 
enforces a 1024 character limit.

Use notification messages when you want the FCM SDK to handle displaying a notification 
automatically when your app is running in the background. Use data messages when you 
want to process the messages with your own client app code.

FCM can send a notification message including an optional data payload. In such cases, 
FCM handles displaying the notification payload, and the client app handles the 
data payload.

Notification messages are delivered to the notification tray when the app is in the 
background. For apps in the foreground, messages are handled by a callback function.

For Android there is a limit of 100 messages that can be stored without collapsing. 
If the limit is reached, all stored messages are discarded. When the device is back 
online, it receives a special message indicating that the limit was reached. The app 
can then handle the situation properly, typically by requesting a full sync from the 
app server.

A collapsible message is a message that may be replaced by a new message if it has yet 
to be delivered to the device.

To mark a message as collapsible on Android, include the collapse_key parameter in the 
message payload. By default, the collapse key is the app package name registered in 
the Firebase console. The FCM server can simultaneously store four different collapsible 
messages per device, each with a different collapse key. If you exceed this number, 
FCM only keeps four collapse keys, with no guarantees about which ones are kept.

Topic messages with no payload are collapsible by default. Notification messages are 
always collapsible and will ignore the collapse_key parameter.

Setting the priority of a message
----------------------------------
i. Normal priority. Normal priority messages are delivered immediately when the app is 
in the foreground. For backgrounded apps, delivery may be delayed. For less 
time-sensitive messages, such as notifications of new email, keeping your UI in sync, 
or syncing app data in the background, choose normal delivery priority.

ii.High priority. FCM attempts to deliver high priority messages immediately even if 
the device is in Doze mode. High priority messages are for time-sensitive, user 
visible content.

When sending data messages to Apple devices, the priority must be set to 5, or 
normal priority. Messages sent with high priority are rejected by the FCM backend 
with the error INVALID_ARGUMENT.

example
---------

{
  "message":{
    "topic":"subscriber-updates",
    "notification":{
      "body" : "This week's edition is now available.",
      "title" : "NewsMagazine.com",
    },
    "data" : {
      "volume" : "3.21.15",
      "contents" : "http://www.news-magazine.com/world-week/21659772"
    },
    "android":{
      "priority":"normal"
    },
    "apns":{
      "headers":{
        "apns-priority":"5"
      }
    },
    "webpush": {
      "headers": {
        "Urgency": "high"
      }
    }
  }
}

Setting the lifespan of a message
----------------------------------

On Android and Web/JavaScript, you can specify the maximum lifespan of a message. 
The value must be a duration from 0 to 2,419,200 seconds (28 days), and it corresponds 
to the maximum period of time for which FCM stores and attempts to deliver the message. 
Requests that don't contain this field default to the maximum period of four weeks.

Here are some possible uses for this feature:

1. Video chat incoming calls
2. Expiring invitation events
3. Calendar events

Another advantage of specifying the lifespan of a message is that FCM never throttles 
messages with a time-to-live value of 0 seconds. In other words, FCM guarantees best 
effort for messages that must be delivered "now or never." Keep in mind that a time_to_live 
value of 0 means messages that can't be delivered immediately are discarded. 
However, because such messages are never stored, this provides the best latency for 
sending notification messages.

Here is an example of a request that includes TTL:

{
  "message":{
    "token":"bk3RNwTe3H0:CI2k_HHwgIpoDKCIZvvDMExUdFQ3P1...",
    "data":{
      "Nick" : "Mario",
      "body" : "great match!",
      "Room" : "PortugalVSDenmark"
    },
    "apns":{
      "headers":{
        "apns-expiration":"1604750400"
      }
    },
    "android":{
      "ttl":"4500s"
    },
    "webpush":{
      "headers":{
        "TTL":"4500"
      }
    }
  }
}

Lifetime of a message
-----------------------

When an app server posts a message to FCM and receives a message ID back, 
it does not mean that the message was already delivered to the device. 
Rather, it means that it was accepted for delivery. What happens to the 
message after it is accepted depends on many factors.

In the best-case scenario, if the device is connected to FCM, the screen is 
on and there are no throttling restrictions, the message is delivered 
right away.

If the device is connected but in Doze, a low priority message is stored by 
FCM until the device is out of Doze. And that's where the collapse_key flag 
plays a role: if there is already a message with the same collapse key 
(and registration token) stored and waiting for delivery, the old message 
is discarded and the new message takes its place (that is, the old message 
is collapsed by the new one). However, if the collapse key is not set, both 
the new and old messages are stored for future delivery.


For Android devices with direct channel messaging enabled, if the device has 
not connected to FCM for more than one month, FCM still accepts the message but 
immediately discards it. If the device connects within four weeks of the last 
data message you sent to it, your client receives the onDeletedMessages() 
callback. The app can then handle the situation properly, typically by 
requesting a full sync from the app server.

Finally, when FCM attempts to deliver a message to the device and the app was 
uninstalled, FCM discards that message right away and invalidates the registration 
token. Future attempts to send a message to that device results in a 
NotRegistered error.

Adding analytics labels to messages
------------------------------------

Labeling messages is very useful for custom analysis, allowing you to filter 
delivery statistics by labels or sets of labels. You can add a label to any 
message sent via the HTTP v1 API by setting the fcmOptions.analyticsLabel field 
in the message object, or in the platform-specific AndroidFcmOptions or 
ApnsFcmOptions fields.

Labeling messages is very useful for custom analysis, allowing you to filter 
delivery statistics by labels or sets of labels. You can add a label to any 
message sent via the HTTP v1 API by setting the fcmOptions.analyticsLabel field 
in the message object, or in the platform-specific AndroidFcmOptions or 
ApnsFcmOptions fields.

Max length is 50 characters. You can specify up to 100 unique labels per 
day; messages with labels added beyond that limit are not reported.


Setup
-------
Configure Web Credentials with FCM
-------------------------------------

The FCM Web interface uses Web credentials called 
"Voluntary Application Server Identification," or "VAPID" keys, to 
authorize send requests to supported web push services. To subscribe 
your app to push notifications, you need to associate a pair of keys with
your Firebase project. You can either generate a new key pair or import your 
existing key pair through the Firebase console.

flutter pub add firebase_messaging

Access the registration token
-------------------------------
final fcmToken = await FirebaseMessaging.instance.getToken();

on Web
//the public key.
final fcmToken = await FirebaseMessaging.instance.getToken(vapidKey: "BKagOny0KF_2pCJQ3m....moL0ewzQ8rZu");

FirebaseMessaging.instance.onTokenRefresh
    .listen((fcmToken) {
      // TODO: If necessary send token to application server.

      // Note: This callback is fired at each app startup and whenever a new
      // token is generated.
    })
    .onError((err) {
      // Error getting token.
    });
    
    
    
Handling interaction
----------------------

1. getInitialMessage(): If the application is opened from a terminated state, 
this method returns a Future containing a RemoteMessage. Once consumed, 
the RemoteMessage will be removed.

2. onMessageOpenedApp: A Stream which posts a RemoteMessage when the application 
is opened from a background state.
    
Example

class Application extends StatefulWidget {
  @override
  State<StatefulWidget> createState() => _Application();
}

class _Application extends State<Application> {
  // In this example, suppose that all messages contain a data field with the key 'type'.
  Future<void> setupInteractedMessage() async {
    // Get any messages which caused the application to open from
    // a terminated state.
    RemoteMessage? initialMessage =
        await FirebaseMessaging.instance.getInitialMessage();

    // If the message also contains a data property with a "type" of "chat",
    // navigate to a chat screen
    if (initialMessage != null) {
      _handleMessage(initialMessage);
    }

    // Also handle any interaction when the app is in the background via a
    // Stream listener
    FirebaseMessaging.onMessageOpenedApp.listen(_handleMessage);
  }

  void _handleMessage(RemoteMessage message) {
    if (message.data['type'] == 'chat') {
      Navigator.pushNamed(context, '/chat',
        arguments: ChatArguments(message),
      );
    }
  }

  @override
  void initState() {
    super.initState();

    // Run code required to handle interacted messages in an async function
    // as initState() must not be async
    setupInteractedMessage();
  }

  @override
  Widget build(BuildContext context) {
    return Text("...");
  }
}

3. foreground

FirebaseMessaging.onMessage.listen((RemoteMessage message) {
  print('Got a message whilst in the foreground!');
  print('Message data: ${message.data}');

  if (message.notification != null) {
    print('Message also contained a notification: ${message.notification}');
  }
});

On Android, you must create a "High Priority" notification channel.
On iOS, you can update the presentation options for the application.

Handle background messages by registering a onBackgroundMessage handler. 
When messages are received, an isolate is spawned (Android only, iOS/macOS 
does not require a separate isolate) allowing you to handle messages even 
when your application is not running.

@pragma('vm:entry-point')
Future<void> _firebaseMessagingBackgroundHandler(RemoteMessage message) async {
  // If you're going to use other Firebase services in the background, such as Firestore,
  // make sure you call `initializeApp` before using other Firebase services.
  await Firebase.initializeApp();

  print("Handling a background message: ${message.messageId}");
}

void main() {
  FirebaseMessaging.onBackgroundMessage(_firebaseMessagingBackgroundHandler);
  runApp(MyApp());
}

Request permission to receive messages (Apple and Web)
-------------------------------------------------------

FirebaseMessaging messaging = FirebaseMessaging.instance;

NotificationSettings settings = await messaging.requestPermission(
  alert: true,
  announcement: false,
  badge: true,
  carPlay: false,
  criticalAlert: false,
  provisional: false,
  sound: true,
);

authorized: The user granted permission.
denied: The user denied permission.
notDetermined: The user has not yet chosen whether to grant permission.
provisional: The user granted provisional permission

On Android authorizationStatus will return authorized if the user has not 
disabled notifications for the app via the operating systems settings.    
    
    
    
    
----------------------------------
Custom camera
----------------------------------    
Flutter camera
-------------------
Images
-------
    
    
    

Appendix
---------

Displaying based on different orientations
---------------------------------------------
1. Orientation Builder (https://docs.flutter.dev/cookbook/design/orientation#:~:text=To%20determine%20the%20app's%20current,size%20of%20the%20parent%20changes.)

The OrientationBuilder calculates the current Orientation 
by comparing the width and height available to the parent 
widget, and rebuilds when the size of the parent changes.

OrientationBuilder(
   builder: (context,orientation) {
   	if (orientation == Orientation.potrait){
   	
   	}
   	if (orientation == Orientation.landscape){
   	
   	}		
   }
)

2. MediaQuery

If you’re interested in the orientation of the screen, 
rather than the amount of space available to the parent, 
the it is best to use MediaQuery.of(context).orientation instead of 
an OrientationBuilder widget.


-----------------------------------------
Running code in background
----------------------------------------
1. Using compute

Compute makes running background isolate easier because we don't have to
manually create SendPort and RecievePort our self.

The function must be a top level function

Compute(Function,parameters);

1.1 Fix for BackgroundIsolateBinaryMessenger


In the fix for it we get the instance of the current ui in the button

final token = RootIsolateToken.instance.

The token for the root isolate that is executing this Dart code. If 
this Dart code is not executing on a root isolate instance will be null.

A token that represents the root isolate, used for coordinating with background isolates.

This property is primarily intended for use with BackgroundIsolateBinaryMessenger.ensureInitialized, 
which takes a RootIsolateToken as its argument. The value null is returned 
when executed from background isolates.

//Then pass the token to the function to run in the compute then in the
// Compute function

BackgroundIsolateBinaryMessenger.ensureInitialized(token);



--------------------------------------------------------
Calling setState in a dialog
--------------------------------------------------------
By default dialogs don't use the same context as the parent from which it was called
we can refresh the ui by wrapping it in a StatefulBuilder which has its own
state and setState 

example:

await showDialog<void>(
  context: context,
  builder: (BuildContext context) {
    int? selectedRadio = 0;
    return AlertDialog(
      content: StatefulBuilder(
        builder: (BuildContext context, StateSetter setState) {
          return Column(
            mainAxisSize: MainAxisSize.min,
            children: List<Widget>.generate(4, (int index) {
              return Radio<int>(
                value: index,
                groupValue: selectedRadio,
                onChanged: (int? value) {
                  setState(() => selectedRadio = value);
                },
              );
            }),
          );
        },
      ),
    );
  },
);

Source: https://api.flutter.dev/flutter/widgets/StatefulBuilder-class.html


DidupdateWidget, DidDependenciesChange and DidStateChange
-----------------------------------------------------------

1. DidupdateWidget

If the parent widget rebuilds and requests that this location in the tree 
update to display a new widget with the same runtimeType and Widget.key, the 
framework will update the widget property of this State object to refer to the 
new widget and then call this method with the previous widget as an argument.

dirty property

When we call the setState method. The framework then marks the widget as dirty. 
Whenever the State object is dirty(dirty is true), it has to be rebuilt by 
calling the build method to reflect the change.

deactivate method

The framework calls this method whenever it removes this State object from 
the tree. In some cases, the framework will reinsert the State object into 
another part of the tree (e.g., if the subtree containing this State object 
is grafted from one location in the tree to another due to the use of a GlobalKey).


2. DidDependenciesChange




https://api.flutter.dev/flutter/widgets/State/didUpdateWidget.html
https://medium.com/@NALSengineering/flutter-from-zero-to-hero-part-8-widget-lifecycle-in-action-8dcb9abf3dcf



------------------------
Gesture on TextSpan
-----------------------

TextSpan(
  text: "Terms and Conditions.",
  recognizer: TapGestureRecognizer()
   ..onTap = () => Navigator.of(context)
       .push(MaterialPageRoute(
              builder: (ctx) =>
              ListenableProvider.value(
               value: provider,
                child:
                 const TermsAndConditions(),
                  ))),
              style: AppTextStyles.fw400(
            fontFamily: AppConstants.libreFranklin,
            fontSize: 13,
            color: AppColors.splashColor),
    )


----------------------------
Scoped provider
----------------------------
ChangeNotifer

then have a child that is a widget

then in the navigation to the second screen you can 
use a ListenableProvider.value(
	value: provider
	child: Screen()

wrapped in the widget of the screen you are navigating to.


--------------------------
Permission screen flow
--------------------------
1. Splash screen check permission status
2. open permission screen if not enabled
3. start a timer that checks permission status every 500 milliseconds
   and navigates away once permission is granted.
4. each time button is tapped it requests for permission.


-----------------------
How to fix ios debug build error (swift compile error: (xCode): using bridging headers with 
module interfaces is unsupported)
----------------------------------------

TO fix this add this to the bottom of pod

post_install do |installer|
  installer.pods_project.targets.each do |target|
    flutter_additional_ios_build_settings(target)
    target.build_configurations.each do |config|
      config.build_settings['BUILD_LIBRARY_FOR_DISTRIBUTION'] = 'NO'
    end
  end
end

not the 2 space indexing.

Then open the ios folder in xcode, 
1. select pod  
2. Build settings
3. Search for build library for distrubution and change it to "no"

P.S i tried building with xcode 13 and pod 1.1 with a iphone 14 pro max simulator
but it failed, it ran when i used xcode14 and pod (unknown) with a iphone 14 prox max
simulator.


------------------------------------------------------
Creating a number validate field, like for enter OTP
------------------------------------------------------
void changeFocus(String str) {
    if (str.length == 1) {
      FocusScope.of(context).nextFocus();
    }
    if (str.isEmpty) {
      FocusScope.of(context).previousFocus();
    }
  }
  

-----------------------------------------
pushAndRemoveUntil
----------------------------------------
sources:
https://api.flutter.dev/flutter/widgets/NavigatorState/pushAndRemoveUntil.html#:~:text=To%20remove%20routes%20until%20a,route)%20%3D%3E%20false%20). 

Push the given route onto the navigator, and then remove all the previous 
routes until the predicate returns true. 

To remove all the routes below the pushed route, use a RoutePredicate that 
always returns false (e.g. (Route<dynamic> route) => false).


------------------------------------
Date picker
------------------------------------

Android
----------
source: https://api.flutter.dev/flutter/material/showDatePicker.html

final date = await showDatePicker(
  context: context,
  initialDate: DateTime.now(),
  firstDate: DateTime(1990),
  lastDate: DateTime.now(),
);

This returns a future with of the date time.

IOS
----
sources: https://api.flutter.dev/flutter/cupertino/CupertinoDatePicker-class.html

CupertinoDatePicker(
  initialDateTime: DateTime.now(),
  maximumDate: DateTime.now(),
  onDateTimeChanged: (dateTime) {
    dateOfBirth = dateTime;
    setState(() {});
});



---------------------------
Formatting date time
---------------------------

Intl
-----

sources: https://pub.dev/packages/intl

DateFormat.yMMMMEEEEd().format(aDateTime);
  ==> 'Wednesday, January 10, 2012'
DateFormat('EEEEE', 'en_US').format(aDateTime);
  ==> 'Wednesday'
DateFormat('EEEEE', 'ln').format(aDateTime);
  ==> 'mokɔlɔ mwa mísáto'
  
  
DateFormat.yMd('en_US').parse('1/10/2012');
DateFormat('Hms', 'en_US').parse('14:23:01');

DateFormat.yMEd().add_jms().format(DateTime.now());
  ==> 'Thu, 5/23/2013 10:21:47 AM'
  
This library uses the ICU/JDK date/time pattern specification 
both for complete format specifications and also the abbreviated 
'skeleton' form which can also adapt to different locales and is 
preferred where available.  

Skeletons: These can be specified either as the ICU constant name 
or as the skeleton to which it resolves. The supported set of 
skeletons is as follows. For each skeleton there is a named constructor 
that can be used to create it. It's also possible to pass the skeleton 
as a string, but the constructor is preferred. 
example .yMed(),

ICU Name                   Skeleton
 --------                   --------
 DAY                          d
 ABBR_WEEKDAY                 E
 ......
 
 Explicit Pattern Syntax
 -------------------------
 
 Symbol   Meaning                Presentation       Example
------   -------                ------------       -------
G        era designator         (Text)             AD
y        year                   (Number)           1996
M        month in year          (Text & Number)    July & 07
......

Symbol   Meaning                Presentation       Example
------   -------                ------------       -------
z        time zone              (Text)             Pacific Standard Time
Z        time zone (RFC 822)    (Number)           -0800
v        time zone (generic)    (Text)             Pacific Time

Text:

5 pattern letters--use narrow form for standalone. Otherwise not used.
4 or more pattern letters--use full form,
3 pattern letters--use short or abbreviated form if one exists
less than 3--use numeric form if one exists

Number: the minimum number of digits. Shorter numbers are zero-padded 
to this amount (e.g. if 'm' produces '6', 'mm' produces '06'). 
Year is handled specially; that is, if the count of 'y' is 2, the Year 
will be truncated to 2 digits. 
(e.g., if 'yyyy' produces '1997', 'yy' produces '97'.) Unlike other 
fields, fractional seconds are padded on the right with zero. 

 
(Text & Number): 3 or over, use text, otherwise use number.

to escape characters wrap them in ''



--------------------------------------------------------
Light and dark theme, based on both system and manually
--------------------------------------------------------
We can choose darkmode, light mode or system.

1. move our changenotifers to main
2. in myapp add 

@override
  void initState() {
    super.initState();
     updateDarkModeStatus();
    WidgetsBinding.instance.addObserver(this);
  }
  
   void updateDarkModeStatus() async {
    final provider = context.read<ThemeChangeNotifier>();
    final status = await DataStorage.darkModeStatus();
    if (status != null) {
      provider.updateDarkMode((status) ? Brightness.dark : Brightness.light);
    } else {
      final brightness =
          WidgetsBinding.instance.platformDispatcher.platformBrightness;
      provider.updateDarkMode(brightness);
    }
  }

  @override
  void didChangePlatformBrightness() async {
    super.didChangePlatformBrightness();
    final provider = context.read<ThemeChangeNotifier>();
    //if storage key is null, assumer we selected system mode.
    //we tried MediaQuery but it was returning the old state of
    // the brightness
    final status = await DataStorage.darkModeStatus();
    if (status == null) {
      final brightness =
          WidgetsBinding.instance.platformDispatcher.platformBrightness;
      provider.updateDarkMode(brightness);
    }
  }


3. our provider

class ThemeChangeNotifier extends ChangeNotifier {
  bool _isDarkMode = false;

  get isDarkMode => _isDarkMode;

  void updateDarkMode(Brightness brightness) {
    if (brightness == Brightness.dark) {
      _isDarkMode = true;
    } else {
      _isDarkMode = false;
    }
    notifyListeners();
  }
}


4. body of our myApp

return Consumer<ThemeChangeNotifier>(
      builder: (context, provider, child) => MaterialApp(
        debugShowCheckedModeBanner: false,
        title: 'Border',
        // darkTheme: AppTheme.darkTheme,
        theme: (provider.isDarkMode) ? AppTheme.darkTheme : AppTheme.lightTheme,
        // themeMode: provider.themeMode,
        home: const SplashScreen(),
      ),
    );
    
5. A basic theme

class AppTheme {
  //Themes
  static final darkTheme = ThemeData(
      scaffoldBackgroundColor: AppColors.scaffoldBackgroundColorDark,
      brightness: Brightness.dark,
      elevatedButtonTheme: ElevatedButtonThemeData(style: ButtonStyle(
          backgroundColor: MaterialStateProperty.resolveWith((states) {
        if (states.contains(MaterialState.disabled)) {
          return Colors.grey;
        }
        return null;
      }))));

  static final lightTheme = ThemeData(
      scaffoldBackgroundColor: AppColors.alabastar,
      brightness: Brightness.light,
      elevatedButtonTheme: ElevatedButtonThemeData(style: ButtonStyle(
          backgroundColor: MaterialStateProperty.resolveWith((states) {
        if (states.contains(MaterialState.disabled)) {
          return Colors.grey;
        }
        return null;
      }))));
}

Creating a singleton in dart
------------------------------
class Singleton{
	static final Singleton _singleton = Singleton._internal();
	
	factory Singleton(){
	  return _singleton;
	}
	
   Singleton._internal();
}

passing variables

class Singleton{
  static final Singleton _singleton = Singleton._internal();
  
  factory Singleton(int variable){
    _singleton.variable = variable;
    return _singleton;
  }
  
  Singleton._internal();
  
  late int variable;
}
